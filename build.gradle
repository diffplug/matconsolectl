plugins {
	id 'com.diffplug.blowdryer'
	id 'com.diffplug.spotless-changelog'
	// for downloading JRE6
	id "de.undercouch.download" version "5.4.0"
}

repositories {
	mavenCentral()
}

spotlessChangelog {
	changelogFile 'CHANGES.md'
}
apply from: 干.file('base/changelog.gradle')

//////////
// JAVA //
//////////
apply plugin: 'java'
sourceCompatibility = VER_JAVA
targetCompatibility = VER_JAVA
apply from: 干.file('spotless/java.gradle')

dependencies {
	testImplementation "junit:junit:${VER_JUNIT}"
}

////////////////////
// MATLAB TESTING //
////////////////////
// standard `gradlew test` can't handle tests which require a MATLAB installation
test {
	// test
	useJUnit {
		excludeCategories 'matlabcontrol.MatlabRequired$Interactive'
		excludeCategories 'matlabcontrol.MatlabRequired$Headless'
	}
}

task testMatlabHeadless(type: Test) {
	useJUnit {
		includeCategories 'matlabcontrol.MatlabRequired$Headless'
	}
}
task testMatlabInteractive(type: Test) {
	useJUnit {
		includeCategories 'matlabcontrol.MatlabRequired$Interactive'
	}
}
task testMatlabAll(dependsOn: [
	test,
	testMatlabHeadless,
	testMatlabInteractive
])

//////////
// OSGI //
//////////

// delete the old manifest to ensure there's no caching or merging going on
jar.doFirst {
	project.file('META-INF/MANIFEST.MF').delete()
}

project.version = project.hasProperty('ver') ? project['ver'] : "${project.version}"
jar.manifest {
	attributes (
		'Bundle-Description': "${project.description}",
		'Bundle-DocURL': "https://${project.git_url}",
		'Bundle-License': "https://${project.git_url}/blob/v${version}/LICENSE",
		'Bundle-ManifestVersion': "${osgi_manifest_ver}",
		'Bundle-SymbolicName': "${project.group}.${project.name}",
		'Bundle-Vendor': "${project.org}",
		'Bundle-Version': "${project.version}",
	    'Export-Package': "matlabcontrol;version=\"${project.version}\",matlabcontrol.demo;version=\"${project.version}\",matlabcontrol.extensions;uses:=matlabcontrol;version=\"${project.version}\",matlabcontrol.internal;version=\"${project.version}\",matlabcontrol.link;uses:=matlabcontrol;version=\"${project.version}\"",
		'Main-Class': 'matlabcontrol.demo.DemoMain',
		'Require-Capability': 'osgi.ee;filter:="(&(osgi.ee=JavaSE)(version=1.7))"'
	)
}

////////////
// JAVA 6 //
////////////

// matlabcontrol requires at least Java 1.6,
// but older MATLABs run on even older versions

// URL for downloading the JRE6
// others available here, OS doesn't matter: https://github.com/alexkasko/openjdk-unofficial-builds#openjdk-6-build-30
def JDK6_URL = 'https://bitbucket.org/alexkasko/openjdk-unofficial-builds/downloads/openjdk-1.6.0-unofficial-b30-windows-i586-image.zip'
def JDK6_SHA_256 = '8a119a8c9b2ecc48e8457738f57b251e6265b2c0fb232de0ff6fddce0f127045'
// place where the JRE6 will end up
def JDK6_DIR = "${buildDir}/jdk"
def JDK6_DST = "${JDK6_DIR}/jdk.zip"
def JRE6_HOME = "${buildDir}/jdk/openjdk-1.6.0-unofficial-b30-windows-i586-image/jre"

import de.undercouch.gradle.tasks.download.Download;
import de.undercouch.gradle.tasks.download.Verify;

task downloadJRE6(type: Download) {
	src JDK6_URL
	dest JDK6_DST
	overwrite false
}

task verifyJRE6(dependsOn: downloadJRE6, type: Verify) {
	src downloadJRE6.dest
	algorithm 'SHA-256'
	checksum JDK6_SHA_256
}

task unzipJRE6(dependsOn: verifyJRE6, type: Copy) {
	from zipTree(downloadJRE6.dest)
	into JDK6_DIR
}

// Best bet is to stay at 1.6
sourceCompatibility = 1.6
targetCompatibility = 1.6
def sep = System.getProperty('path.separator')
def bootClasspathStr = project.files("${JRE6_HOME}/lib/rt.jar${sep}${JRE6_HOME}/lib/jsse.jar")
project.tasks.withType(AbstractCompile, { AbstractCompile ac ->
	ac.options.bootstrapClasspath = bootClasspathStr // options is always there but not defined on AbstractCompile so going to hit it anyway
	ac.dependsOn(unzipJRE6)
})

// we'll want the findbugs annotations (they don't have a 3.0.1 version)
dependencies {
	implementation 'com.google.code.findbugs:annotations:3.0.0'
	implementation 'com.google.code.findbugs:jsr305:3.0.0'
}

// the package of the jmi stub (which we're going to leave out of all the jars we make)
def JMI_STUB = 'com/mathworks/jmi/**'

// make a source jar
task sourcesJar(type: Jar) {
	archiveClassifier = 'sources'
	from sourceSets.main.allJava
	exclude(JMI_STUB)
	manifest {
		attributes (
		'Bundle-Description': "${project.description}",
		'Bundle-DocURL': "https://${project.git_url}",
		'Bundle-License': "https://${project.git_url}/blob/v${version}/LICENSE",
		'Bundle-ManifestVersion': "${osgi_manifest_ver}",
		'Bundle-SymbolicName': "${project.group}.${project.name}",
		'Bundle-Vendor': "${project.org}",
		'Bundle-Version': "${project.version}",
	    'Export-Package': "matlabcontrol;version=\"${project.version}\",matlabcontrol.demo;version=\"${project.version}\",matlabcontrol.extensions;uses:=matlabcontrol;version=\"${project.version}\",matlabcontrol.internal;version=\"${project.version}\",matlabcontrol.link;uses:=matlabcontrol;version=\"${project.version}\"",
		'Main-Class': 'matlabcontrol.demo.DemoMain',
		'Require-Capability': 'osgi.ee;filter:="(&(osgi.ee=JavaSE)(version=1.7))"'
		)
	}
}

// Where it's possible to name parameters and methods clearly enough
// that javadoc is not necessary, why make the code bigger?
//
// Thus, no javadoc warnings.
def makeLink = { url, text -> "<a href=\"${url}\" style=\"text-transform: none;\">${text}</a>" }
def javadocInfo = '<h2>' + makeLink("https://github.com/${org}/${name}", "${group}:${name}:${version}") +
		' by ' + makeLink('http://www.diffplug.com', 'DiffPlug') + '</h2>'
javadoc {
	options.addStringOption('Xdoclint:none', '-quiet')
	options.header javadocInfo
	options.footer javadocInfo
	options.links('https://docs.oracle.com/javase/6/docs/api/')
}

task javadocJar(type: Jar, dependsOn: javadoc) {
	archiveClassifier = 'javadoc'
	from javadoc.destinationDir
}

artifacts {
    archives sourcesJar
}

// it all needs to get published and formatted
apply from: 干.file('base/maven.gradle')
apply from: 干.file('base/sonatype.gradle')